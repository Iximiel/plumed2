#! /usr/bin/env bash

fixzeroes() {
  local file=$1

  grep -q "\x00" "$file" && exit 0

  sed "s/-\(0\.0*0 \)/ \1/g; 
     s/-\(0\.0*0$\)/ \1/g" "$file" >"$file.$$.tmp"
  mv "$file.$$.tmp" "$file"

}

setupAndCheckMPI() {
  if ((mpiprocs > 0)); then

    if $plumed_nompi config -q mpiexec; then
      mpi="$($plumed_nompi config mpiexec)"
    fi
    if test -z "$mpi"; then
      mpi="${PLUMED_MPIRUN:-mpirun}"
    fi
    mpi="$mpi -np $mpiprocs"

    if ! $plumed_nompi config -q has mpi; then
      echo "NOT_APPLICABLE (MPI NOT INSTALLED)"
      return 125
    fi
    if [[ "$valgrind" != "env" ]]; then
      echo "NOT_APPLICABLE (MPI cannot be used with valgrind)"
      return 125
    fi
  else

    plumed="$plumed --no-mpi"

  fi
}

checkDependencies() {

  for need in $plumed_needs; do
    echo "Checking for $need"
    if ! $plumed_nompi config -q has $need; then
      if [ "$TRAVIS" = true ] || [ "$GITHUB_ACTIONS" = true ]; then
        if [ -z "$PLUMED_ALLOW_SKIP_ON_TRAVIS" ]; then
          echo "NOT_APPLICABLE ($need NOT ENABLED)"
        else
          echo "SKIP_ON_TRAVIS found!"
        fi
      else
        echo "NOT_APPLICABLE ($need NOT ENABLED)"
      fi
      return 125
    fi
  done

  for module in $plumed_modules; do
    echo "Checking for $module"
    if ! $plumed_nompi config -q module $module; then
      if [ "$TRAVIS" = true ] || [ "$GITHUB_ACTIONS" = true ]; then
        if [ -z "$PLUMED_ALLOW_SKIP_ON_TRAVIS" ]; then
          echo "NOT_APPLICABLE ($module MODULE NOT INSTALLED)"
        else
          echo "SKIP_ON_TRAVIS found!"
        fi
      else
        echo "NOT_APPLICABLE ($module MODULE NOT INSTALLED)"
      fi
      return 125
    fi
  done
}

setup() {
  #copies files into tmp and check if plumed can be run in this environment

  date
  echo "Setting up regtest from $(pwd)"

  if [ "$valgrind" = valgrind ]; then
    echo "using valgrind"
  fi

  rm -fr tmp
  mkdir tmp
  cd tmp || return 1

  cp -f ${dir}/* . 2>/dev/null

  for file in $extra_files; do
    #one of the following will fail is fhe file is not present
    if [[ -f ${dir}/$file ]]; then
      #relative path
      cp -fv "${dir}/$file" .
    else
      #absolute path
      cp -fv "$file" .
    fi
  done

  root=$($plumed_nompi info --root)

  if test -z "$root"; then
    echo "root: $root"
    echo "FAILURE: plumed executable not available"
    exit 1
  fi

  if [[ -x plumed_custom_skip ]]; then
    if ./plumed_custom_skip; then
      if [ "$TRAVIS" = true ] || [ "$GITHUB_ACTIONS" = true ]; then
        if [ -z "$PLUMED_ALLOW_SKIP_ON_TRAVIS" ]; then
          echo "NOT_APPLIABLE (plumed_custom_skip)"
        else
          echo "SKIP_ON_TRAVIS found!"
        fi
      else
        echo "NOT_APPLIABLE (plumed_custom_skip)"
      fi
      return 125
    fi
  fi

  #export PLUMED_KERNEL
  #export PLUMED_LIB
  #these exports should been made by the -e inputs

  if [[ -x plumed_regtest_before ]]; then
    ./plumed_regtest_before
  fi
}

other() {
  case "$type" in
  simplemd)
    test -f in || {
      echo "FAILURE: in file not present"
      return 1
    }
    $mpi $valgrind $plumed simplemd <in >out 2>err
    ;;
  driver)
    $mpi $valgrind $plumed driver $args >out 2>err
    ;;
  sum_hills)
    $mpi $valgrind $plumed sum_hills $args >out 2>err
    ;;
  make)
    $plumed_nompi --is-installed || ln -s "$root/src" plumed
    if test "$plumed_language" = fortran || test "$plumed_language" = fortran08 || test "$plumed_language" = c; then
      cat <($plumed_nompi info --configuration) "$root/src/lib/Plumed.inc.shared" ../../../scripts/exe.make >Makefile
    else
      cat <($plumed_nompi info --configuration) "$root/src/lib/Plumed.inc.static" ../../../scripts/exe.make >Makefile
    fi
    if test "$plumed_language" = fortran || test "$plumed_language" = fortran08; then
      if make print-fortran | grep "FC=$" 1>/dev/null; then
        echo "NOT_APPLICABLE (FC NOT FOUND)"
        return 2
      else
        if test "$plumed_language" = fortran08; then
          cat >__test_fortran08.f90 <<EOF
module test_fortran08_a
implicit none
type b
contains
final :: c
end type b
contains
impure elemental subroutine c(x)
type(b), intent(inout) :: x
end subroutine c
subroutine sub(x)
integer :: x(:)
write(*,*) is_contiguous(x)
end subroutine sub
end module test_fortran08_a
EOF
          if make test-fortran08 2>err | grep SUCCESS=YES 1>/dev/null; then
            make exe-fortran08 1>out 2>err
          else
            echo "NOT_APPLICABLE (FC does not support f2008)"
            return 2
          fi
        else
          make exe-fortran 1>out 2>err
        fi
      fi
    elif test "$plumed_language" = c || test "$plumed_language" = c11; then
      if test "$plumed_language" = c11; then
        cat >__test_c11.c <<EOF
#ifdef __STDC_VERSION__
#if __STDC_VERSION__ < 201112L
error
#endif
#else
error
#endif

int f(int a){
int x;
x=_Generic( 'a', char: 1, int: 2, long: 3, default: 0);
return a;
}
EOF
        if make test-c11 2>err | grep SUCCESS=YES 1>/dev/null; then
          rm __test_c11.c
          make exe-c 1>out 2>err
        else
          echo "NOT_APPLICABLE (CC does not support c11)"
          return 2
        fi
      else
        make exe-c 1>out 2>err
      fi
    else
      make exe 1>out 2>err
    fi
    $mpi $valgrind ./exe $args >>out 2>>err
    ;;
  plumed)
    $mpi $valgrind $plumed $args >out 2>err
    ;;
  python)
    # make sure the right python module is in the path based on plumed root
    PYTHONPATH="$root/python:$PYTHONPATH" $($plumed_nompi config python_bin) $arg >out 2>err
    ;;
  *)
    echo "FAILURE: unknown test type \"${type}\""
    return 1
    ;;
  esac
  exitcode="$?"
  if test $exitcode -ne 0; then
    echo "FAILURE: exit code $exitcode"
    return 1
  fi

}

run_plumed() {
  runcommand="$mpi $plumed"
  echo "running \"$runcommand ${args} > out 2> err\""
  #here I need splitting
  $runcommand ${args} >out 2>err
  returnvalue=$?
  if [[ -s err ]]; then
    echo "####stderr contains:####"
    cat err
    echo "########################"
  fi
  return $returnvalue
}

run_driver() {
  args="driver ${args}"
  run_plumed
}

run_simplemd() {
  args="simplemd ${args}"
  run_plumed
}

run_sum_hills() {
  args="sum_hills ${args}"
  run_plumed
}

run_make() {
  otherLang=""
  filesC=$(ls ./*.c 2>/dev/null)
  filesf90=$(ls ./*.f90 2>/dev/null)
  files=$(ls ./*.cpp ./*.f90 ./*.c 2>/dev/null)
  if [[ -n ${filesf90} ]]; then
    otherLang="${otherLang}enable_language (Fortran)\n"
  fi
  if [[ -n ${filesC} ]]; then
    otherLang="${otherLang}enable_language (C)\n"
  fi
  cat <<EOF >CMakeLists.txt
cmake_minimum_required(VERSION 3.20)
project(exe-test CXX)
$(echo -e "$otherLang")
find_package(Plumed2 REQUIRED)
add_executable(exe ${files})
target_link_libraries(exe PUBLIC
  Plumed2::sharedplumedMain
  #automatically links to the shared kernel Plumed2::sharedplumedKernel 
)
install (TARGETS exe
    RUNTIME DESTINATION ${PWD}
)
EOF
  mkdir build
  {
    cmake -B ./build -S . -DCMAKE_BUILD_TYPE:STRING=Release &&
      cmake --build ./build &&
      cmake --install ./build &&
      $mpi $valgrind ./exe $arg
  } >out 2>err
}

check() {
  if [[ -x plumed_regtest_after ]]; then
    ./plumed_regtest_after
  fi

  exitcode=0
  if ls ./*.reference >/dev/null; then
    for file in *.reference; do
      new="${file%.reference}"
      echo "checking $new"
      if test -f "$new"; then

        fixzeroes "$file"
        cp "$new" "$new.zfix"
        fixzeroes "$new.zfix"

        DIFFOPT=""
        # this is to enforce ASCII check
        # I add this option since sometime on travis some of the diff files are not shown
        # (files are thought to be binary for some reason)
        # In this way, at least PLUMED native files (with fields) will be assumed to be
        # ASCII and diff will be shown in the log
        test "$(head -c 10 "$file")" = "#! FIELDS " && DIFFOPT="-a"
        out="$(diff $DIFFOPT "$file" "$new.zfix")"
        diff $DIFFOPT "$file" "$new.zfix"
        test -n "$out" && {
          echo FAILURE
          echo "Diff for ${file%.reference}:"
          echo "$out"
        }
      else
        echo "FAILURE: FILE $new does not exist"
        exitcode=1
      fi
    done
  else
    echo "WARNING: no file has been checked"
    exitcode=2
  fi

  return $exitcode
}

#this settings make the pipe exit with failure code of any command
#so the program exits with the exit state of the scripta and not the
#one of tee
set -o pipefail
{
  if test -n "$PLUMED_PREPEND_PATH"; then
    PATH="$PLUMED_PREPEND_PATH:$PATH"
  fi

  # this is the executable used for running the tests:
  plumed=$1
  shift 1
  # this is the executable used for getting the configuration:
  plumed_nompi="$plumed --no-mpi"

  mpi=""
  args=""
  plumed_modules=""
  plumed_needs=""
  extra_files=""

  export valgrind=env

  while getopts "a:d:e:f:l:m:n:p:t:v" option; do
    case "$option" in
    #the directory with the source of the ttest
    a) args=${OPTARG} ;;
    d) dir=${OPTARG} ;;
    e)
      name=${OPTARG%=*}
      value=${OPTARG#*=}
      export "${name}"="$value"
      ;;
    f) extra_files=${OPTARG} ;;
    #${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH} expands to :${LD_LIBRARY_PATH} if LD_LIBRARY_PATH contains something
    l) export LD_LIBRARY_PATH=${OPTARG}${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} ;;
    m) plumed_modules=${OPTARG} ;;
    n) plumed_needs=${OPTARG} ;;
    p) mpiprocs=${OPTARG} ;;
    t) type=${OPTARG} ;;
    #activates valgrind
    v) valgrind="valgrind --leak-check=full --track-origins=yes" ;;
    *)
      echo "ERROR: unknown argument \"$option\""
      exit 1
      ;;
    esac
  done

  cat <<EOF
  ++ dir:  $dir
  ++ Test type: $type
  ++ Arguments: "$args"
  ++ Processors: $mpiprocs
  ++ Extra files: $extra_files
  ++ Plumed needs: $plumed_needs
EOF

  #this runs the different set ups function, the test and the checks and communicate where something is going wrong
  for runner in setupAndCheckMPI checkDependencies setup "run_${type}" check; do
    $runner
    rt=$?
    if [[ $rt != 0 ]]; then
      echo "CAUSE: $runner exited with $rt"
      exit $rt
    fi
  done
  #ctest is producing a report file on its own, but we offer also a more "private" report
} | tee report.txt
