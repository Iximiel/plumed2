#! /usr/bin/env bash
# shellcheck disable=SC2059

problems=""
toPrint='  {"%s", "%s"}'
#regex are scary, here's a link with the flow of the regex
# https://regexper.com/#PLUMED_REGISTER_ACTION%5Cs*%5C%28%5Cs*%5B0-9a-zA-Z_%5D%2B%5Cs*%2C%5Cs*%22%28%5B0-9a-zA-Z_%5D%2B%29%22%5Cs*%5C%29
regex='PLUMED_REGISTER_ACTION[ ]*\([ ]*[0-9a-zA-Z_]+[ ]*,[ ]*"([0-9a-zA-Z_]+)"[ ]*\)'

for module in ../*/module.type; do
  moduledir=${module%%/module.type}
  modulename=${moduledir##*/}
  {
    for file in "$moduledir"/*.cpp; do
      if grep -q PLUMED_REGISTER_ACTION "${file}"; then
#         # gawk and perl implementation in case your bash dialect do not process correctly the regex
#         # action=$(gawk 'match($0,/PLUMED_REGISTER_ACTION\s*\(\s*[0-9a-zA-Z_]+\s*,\s*"([0-9a-zA-Z_]+)"\s*\)/, captured){print captured[1]}' "${file}" )
#         # in case gawk does not work, here's the perl implementation:
#         action=$(perl -ln -e'print $1 if /PLUMED_REGISTER_ACTION\s*\(\s*[0-9a-zA-Z_]+\s*,\s*"([0-9a-zA-Z_]+)"\s*\)/' "${file}")
#         ng=$(grep -c PLUMED_REGISTER_ACTION "${file}")
#         nawk=$(
#           cat <<EOF | wc -l
# $action
# EOF
#         )
#         if [[ $ng -ne $nawk ]]; then
#           problems="$problems ${modulename}:${file}"
#         fi
#         for actionName in $action; do
#           printf "$toPrint" "$actionName" "$modulename"
#           # echo -ne "$init  {\"$a\", \"$modulename\"}"
#           toPrint=',\n  {"%s", "%s"}'
#         done
        # pure bash implementation in case gawk or perl do not work (comment the previous part of the if statement)
        grep PLUMED_REGISTER_ACTION "${file}" | while read -r action; do
          # echo $action
          if [[ $action =~ $regex ]]; then
            actionName=${BASH_REMATCH[1]}
            printf "$toPrint" "$actionName" "$modulename"

            toPrint=',\n  {"%s", "%s"}'
          fi
        done
        #also here becasue while spawns a subshell and toPrint do not get updated
        toPrint=',\n  {"%s", "%s"}'
      fi
    done
  }

done
echo -e '\n'
if [[ -n $problems ]]; then
  echo >&2 some problems in the following:
  for p in $problems; do
    echo >&2 $p
  done
  exit 1
fi
